// x = 1
// создание глобальной переменной в функции
// сначала идёт проверка есть ли такая перемення и если нет то создаётся глобальная перермення даже если она создана в функции


// условия
// если условие в блоке "if" будет правдивым то будет сполнен код после этого блока, а если не, то будет исполнен код который указан в блоке "else"
// if (условия при котором будет выполнен код) {сам код}
// так-же после "else" можно писать ещё блоки с условиями "if" и такими-же блоками "else" которые будут выполнены какобычно, но писать "else" не обизательно, они тоже буду проверятся если все условие выше не буду правдой
if (name == 'ToxaN') {
	console.log(age)
} else {
	console.log(age2)
}

if (name1 != 'ToxaN') {
	console.log('no')
} else {
	console.log('ye')
}

// можно укаратить такой код вот так: let a = (a < 18) ? true: false
// если условие правдиво, то возврашается первое значение, а если не, то второе
// оператор "?" имеет низкий проиритет и можно не ставить скобки
// так-же это можно использовать несколько раз например: let a = promt("How old are you?"); let resulr = (a < 18) ? "Oke bro": (a > 18) ? "You old": (a > 100) ? "Wat????"
// можно использовать место if, но не рекомендую: let a = promt(18?); (a < 18) ? alert("Go"): alert("fuck")

// оператор или - "||" служит для проверки булевых значений
// только при обоих значениях "false" будет записано ложное значение, а вовсех других случаях "true"
// можно за раз ставить много сравнений
// let a = f1 || f2 || f3; этот код даёт возможность сравнивать значение и выбир из них первое правельное, а если все "false" то возврашается последние


// "&&" (И) оператор который возврашает значение "true", только при условии значений "true" в всех значениях
// перебирает значение с лева на право и останавливается при певром "false" или последнеи если другое не найдено
// при вызове фкеции alert(1 && 5); результатом будет 5
// приоритет у "&&" больше чем у "||"

// если при проверке "||" или "&&" у одного из операторов будет не будет будет значение, а будет код, то этот код будет выполнен

// "!" (не) преобразует в логическуе и приводит к противоположному значению alert(!"numder") true
// "!!" просто прелбразовует в логическое значение

// "!" имеет найвиший приоритет

// оператор "??" возвращает первий аргумет если он не "null\undefinted" или второй
// "??" возврашает певрое истонное значение, а "||" возврашает первое определённое значени
// для "||" имеет одинаковое значение "0", false, "null", "undefined", а для "??" оно разное

// циклы

// while(условие) {код}

// do{код}while(условие)
// сначала выполняется условие затем проверка

// for(начальное значение;условие;как будет менятся код){код}
// Выполнить *начало*
// → (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
// → (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
// → (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
// → ...
// сначало выполняется один раз начало, потом проверка условия и если оно правдиво то виполняется тело цикла и затем изменяется начальное значение
// встроенная перемення частро моздаётся в начале цикла и используется только там
// можно использовать не создавать пеменние и просто указывать преведушие значение переменной
// можено и пропускать части цыкла
// такое можно использовать как более удобний вариант в случаи с сушествуюший переменной
// при убирании "шага" мы создадим цикл "while"

// "break" останавливает переменную
// "continue" позволяет пропустить виполнение цикла

// .lenght - измеряем количество елементов

// есть возможность вложить значение цикла в его название и при надобности остановить
// outer: for (let i = 0; i < 3; i++) {

// 	for (let j = 0; j < 3; j++) {
  
// 	  let input = prompt(`Значение на координатах (${i},${j})`, '');
  
// 	  // если пустая строка или Отмена, то выйти из обоих циклов
// 	  if (!input) break outer; // (*)
  
// 	  // сделать что-нибудь со значениями...
// 	}
//   }
  
//   alert('Готово!');
// тут ми создаём цикл проверки первой переменной и потом виводим значение переменной на один больше и при отсудствии значений в соглачии отвечать пользователю то он останавливается

// "swtch" заменяет "if"
// если "х" равно...
// switch(x) {
	// если "х" равно "value1" то виполняется код ниже
// 	case 'value1':  // if (x === 'value1')
// 	  ...
// 	  [break]
  
	// или если "х" равно "value2" то виполнится код ниже
// 	case 'value2':  // if (x === 'value2')
// 	  ...
// 	  [break]
  
	// или если не подходит ничего то выполнится код ниже
// 	default:
// 	  ...
// 	  [break]
//   }
// после выполнения условия которое совпало будет выполенено всё что ниже, по этому нужно ставить "break" после каждого "case"
// выполненое действие будет выплнятся до ближайшего "break"
// проверка на равенство строгая

// for..in
// создаём переменную в которую помешаем значение обьэкта
// let user = {
	// name: "John",
	// age: 30,
	// isAdmin: true
  // };
  
  // for (let key in user) {
	// ключи
	// alert( key );  // name, age, isAdmin
	// значения ключей
	// alert( user[key] ); // John, 30, true
  // }
// при вызове всех обьэктов функции целочисленные располагаются в порядке возростания, а остальные по порядку создания
// если в обьэкте есть значения и с целочисленными значениями и с другими то сначала идут обычные, а за тем целочисленные
// добавление знака "+" будет достаточно чтобы число стало обычным

// обьекты

// обычные переменные копируются по значению, а обьэкты по ссылке
let user = { name: "Иван" };

let admin = user; // копируется ссылка

// Мы можем использовать любую из переменных для доступа к ящику и изменения его содержимого

let user1 = { name: 'Иван' };

let admin1 = user;

admin1.name = 'Петя'; // изменено по ссылке из переменной "admin"

// alert(user.name); // 'Петя', изменения видны по ссылке из переменной "user"

// обычное равенства и строгое равенство однинаковы для обьэктов по скольку обьэкт может быть равен только если все значение совпадают

// для копирования обьэктов

let user2 = {
	name: "Иван",
	age: 30
  };
  
  let clone = {}; // новый пустой объект
  
  // скопируем все свойства user в него
  for (let key in user2) {
	clone[key] = user2[key];
  }
  
  // теперь в переменной clone находится абсолютно независимый клон объекта
  clone.name = "Пётр"; // изменим в нём данные
  
  // alert( user.name ); // в оригинальном объекте значение свойства `name` осталось прежним – Иван.

// для копирования конкретных свойств нужно использовать метод "Obgect.assign"

// Object.assign(dest, [src1, src2, src3...])
// все значения  указаные значение "src1" перемещяются в обьэкт "dest"

// Объединим несколько объектов в один
let user3 = { name: "Иван" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user3, permissions1, permissions2);

// теперь user = { name: "Иван", canView: true, canEdit: true }
// если такое значение уже есть то оно будет перезаписано

// Мы также можем использовать Object.assign для замены for..in на простое клонирование

let user4 = {
	name: "Иван",
	age: 30
  };
  
  let clone = Object.assign({}, user4);
// теперь в обьэкте "clone" все значения "user4"

// обьеденение обьектов

let clone_all = {n1, n2}

// this

// применяется когда в обьекте создали функцию и нужно обратится к значению обьекта

// функцыи

// function function_name(year) {
// 	alert("Helo!")
// }

// function имя функцыи(параметры){код}

// визов функции
// function_name()

// все переменные обьявление в функции являются локальными

// параметры функции это локальные переменные которые могу быть заданы при вызове вункции по порядку
// если в функции мы используем переменную которая была записана в параметры и нам не нужно здавать новое значение то просто пишем её название
// если нам не нужно задавать параметр аргумент то просто пишем его без скобок
// Если параметр не указан, то его значением становится "undefined"
// если мы хотим задать значение по умолчанию то в параметрах нужно записать через "=" его значение


// создаём функцию с параметром которая делает какие-то действия
// функции прогружаются сразуже
// когда такая функция находится в блоке кода то сушествует только в нём
function function_name(year) {
	// делаем переменную доступную для всех
	// так-же можно возвращать пустое значение
	return 2022 - year
}


// создаём переменную которая сипользует функцию и в части с параметрами ставит ему указаное значение
const asd = function_name(1991)
console.log(asd)

// или сразу в консоли
console.log(function_name(1458))

// визов функции
function_name(1234)

function inf(name, year, age, suorename) {
	var a = function_name(year)
}

// функцию можно вызывать и так
// при вызове такой функции нужно просто указать её как переменную, но может работать и как раньше
// такая функция создаётся только когда да неё доходит очередь, а не сразуже
let seyHi = function(){
	alert("Hello!")
}

// обьэкты

// let usr = {
	// ключ: начение
	// name:"Toxa",
	// age: 15,
	// "Name": 16,
	// "like bird": 20,
	//  "size": {
		// width: 152,
		// heidth: 35,
	// },
//}

// можно оставлять запятую в конце
// для вызова значени с обьэкты нужно название обьэкта и через точку вызвать значение
// alert(usr.name)
// alert(usr.size.width)
// для изменение значения обьэкта нужно так
// usr.name = "Anton"
// для добавление нового значения нужно сделоть так
// usr.Bool = true
// для удаления
// delete usr.name
// даже обьэкт созданний через "const" тоже можно менять
// для вызова вункции где есть пробел или которая имеет "" то для вызова и изменения нужно писать так ["like bird"]

// пользователь спрашывает вопрс и в зависимости от ответа идёт запрос в обьэкт и вывод инфы
// мы создаём запрос где получиное значение сопостовляется с данным обьэкта и выводит значение
// let key = promt("Do you want to know about user?", "name")
// alert( user.[key])

// если взять значение обьэкта в квадратные скобки то его значние можно будет присвоить переменной и уже обращатся к параметру в значении переменной
// let fruit = prompt("Какой фрукт купить?", "apple")
// let bag = {
	// запись "[fruit]" означает что значение нужно взять с переменной "fruit"
	//[fruit]: 5, // имя свойства будет взято из переменной fruit
//}
//alert( bag.apple )	

// можно и добавлять значения в имя параметра
// let frut = "World"
// let usr{
	//[frut + "Hello"]: "Hello World!"
//}
// alert(usr.WorldHello) // Hello World!

// часто в коде мы будем испоьзовать значение переменной как значения для свойств с тем же именем
// function makeUser(name, age) {
  // return {
    // name: name,
    // age: age
    // ...другие свойства
  // }
// }
// let user = makeUser("John", 30)
// alert(user.name); // John
// Вместо "name:name" мы можем написать просто "name:"
// мы можем использовать обычные и краткие значение в одной функции

// свойства не имеют ограничений в названиях в отличии от переменной которая не может быть названа зарезервиноваными "let", "var", "const", "return"
// все значение свойств кроме спец символов будут изменены на строку

// let obj = {
	// 0: "Тест" // то же самое что и "0": "Тест"
  // };

  // обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
  // alert( obj["0"] ); // Тест
  // alert( obj[0] ); // Тест (то же свойство)

// оператор "in" может проверить находться ли значение в обьэте
// имя свойства должно быть в кавыйчках
// если мы не ставим кавычки то мы проверяем переменную

// let user = { name: "John", age: 30 };

// alert( "age" in user ); // true, user.age существует
// alert( "blabla" in user ); // false, user.blabla не существует

// создаём функцыю в которой присваеваем путь "woman.husband" к "man" и "man.wife" к "woman"
function marry(man, woman) {
	woman.husband = man;
	man.wife = woman;
  
	// возвращаем их
	return {
	  father: man,
	  mother: woman
	}
  }
  
  // создаём обьэкт где...
  let family = marry({
	// к первому значению присваеваем значение "John" и ссылкой "name"
	name: "John"
  }, {
	// к второму значению присваеваем значение "Ann" и ссылкой "name"
	name: "Ann"
  });
  // пример обрашения по ссылке
  // familu.father
  // famili.mother.husbend

  // для оптимизации удаляй пути которые не используешбь

// метод обьэктов "this"

// для обрашения к обьэктам в функции нужно писать "this", а так-жи при обрашении к другим елементам вне функции

// Функцию, которая является свойством объекта, называют методом этого объекта

// мы можем зписывать функции в обьэкте двумя методами

//длинный
user5 = {
	sayHi: function() {
	  alert("Привет");
	}
  };

// короткий
user6 = {
	sayHi() { // то же самое, что и "sayHi: function()"
	  alert("Привет");
	}
  };

//

  let user7 = {
	name: "Джон",
	age: 30,
	sayHi() {
	  // this - это "текущий объект"
	  // позволяет создать ссылку на параметр и пользоватся ей
	  alert(this.name7);
	}
  };
  user.sayHi(); // Джон

// "this" может создавать ссылки на обьэкты в любом месте

// для использования функций в обьэктах нужно указывать "()"

// new

// создаём функцыю пользователя с возможносью создания нового пользователя
function User(name) {
	this.name = name;
	this.isAdmin = false;
  }
  // создаём ногово пользователя с новым параметром 
  let user8 = new User("Вася");

  // создаётся новый пользователь и первым делом возвращается "this" пустое затем туда вписываются задынные параметры
  
  // alert(user8.name); // Вася
  // alert(user8.isAdmin); // false

// Функции-конструкторы являются обычными функциями. Но есть два соглашения
// 1)Имя функции-конструктора должно начинаться с большой буквы
// 2)Функция-конструктор должна вызываться при помощи оператора "new"

// new.target

// вызывается для проверки как вызвана функуия

function User() {
	alert(new.target);
  }
  
  // без "new":
  // User(); // undefined
  
  // с "new":
  // new User(); // function User { ... }

// при вызове в одной функции и "return" и "this" будет выполнен код с "return"
// при вызове мнтода "return" без указаного кода который будет взарвщен то возвращается "this"

// Использование конструкторов для создания объектов даёт большую гибкость. Можно передавать конструктору параметры, определяющие, как создавать объект, и что в него записывать
// В "this" мы можем добавлять не только свойства, но и методы

function User1(name) {
	this.name = name;
  
	this.sayHi = function() {
	  alert( "Меня зовут: " + this.name );
	};
  }
  
  let vasya = new User("Вася");
  
  // vasya.sayHi(); // Меня зовут: Вася
  
  /*
  vasya = {
	 name: "Вася",
	 sayHi: function() { ... }
  }
  */

// value?.prop
// если в "value" значение есть то оно выполняется как обычное "value.prop" в противном случаи вызврашает "undefind"
let user9 = {}; // пользователь без адреса

alert( user9?.address?.street ); // undefined (без ошибки)
  


// масиви

// создаём массив
const mac = ['Номер 1', 'Namber2', 'Namber3']
// или
const mac2 = new Array('Namber1', 'Namber2', 'Namber3')
// или
const mac3 = ['1', '2', '3']
// меняем значение масива
const mac4 = ['Namber1', 'Namber2', 'Namber3']
mac4[0] = '1'
// добавляем елемент в последнию часть мссива
mac4[mac.lenght] = "12"
// вызов
console.log(mac2[1])
console.log(mac4[0])

// циклы

// создаём переменную с let; пишем условие при котором будет выполнтся действие; если преведушие условие правдиво то выполняем этот код  по отношению к преведушему условию и тогда выполняем тело цикла 
for(let i = 0; i < mac4; i++) {
	console.log("1")
}
// проходимся по всем елементам
for(let all of div_all) {
    all.addEventListener("click", function() {
        console.log("12");
    })
}

// создаём список

const qw = {
	name: "someone",
	age: "12"
}
console.log(qw.age)
// приминение js к елементам HTML

// при ошибке с єтими елементами пиши js прям в HTML коде через <script><\script>

// Doom selector

// взятие елемента по id
document.getElementById("id")

// взятие елемента по class
document.getElementByClassName("class")

// взятие елемента по tag name - находит все елементы по заданому тегу
document.getElementByTagName("html")
// выводится список всех елементов и нужно в квадратных скобках назвать номер елемента

// определение что находится в HTML части с возможностю изменять значение
innerHTML

// выводится первый елемент
document.querySelector("#id", ".class")

// выводятся все елементы
document.querySelectorAll("#id", ".class")
// выводится список всех елементов и нужно в квадратных скобках назвать номер елемента

// изменения текста по id 
document.getElementById("#id").innerHTML = "New id"
// или по class
document.getElementByClassName(".class").innerHTML = "New class"

// изменение класса по клику и изменение класса по повторному клику
toggleClass("class")

// засовываем елементы HTML в переменную js
// название переменной            часть с HTML
const p = document.querySelector(".p")
// вибокра по айди
const header = document.getElementById("header")
// или
const header1 = document.querySelector("#header")
console.log(p)


// измерение времени
getTime()

// задержка по врменени
setTimeout(function(){alert("Hello!"), 3000})

// случайное число
Math.random()

// округление
Math.floor()

// разделение по значением
let h = "0123456789".split('')

// изменения стилей 

let d = document.getElementById("id")

d.style.color = "red"

// добавление класса
 let f = document.getElementByClassName("class")

// добавляет указаний класс
 f.classList.add("add class")

// удаление классов

let w = document.getElementByClassName("class")

// удоляет указаний класс
w.classList.remove("delte class")

// изменение отрибутов

let image = document.getElementsByTagName("img")

// берём значение атрибута scr
image[0].getAttribute("scr")

// берём атрибут и изменям значение на указаное
image[0].setAttribute("scr", "image/img2.png")

// добавление атрибута

let e = document.getElementById("id")

e.setAttribute("width", "100px")

// собития

let r = document.getElementById("id")

r.addEventListener("click", function(){

})

// при скроле задаём функцию котораябудет выполнятся
window.addEventListener("scroll", function() {
    console.log("123")
})

// клик
// название того на что вешаем событие.addEventListener("scroll", function() {
//     console.log("123")
// })
// при скроле 

// меняем класс
window.addEventListener("scroll", function() {
	// в функции мы задаём действие которое будет делатся	
	// classlist эта команда поможет менять классы
	// add добавляет класс
    test2.classList.add("pre")
    // remove удаляет
    test2.classList.add("pre")
    // так-же можно в CSS документе задавать другие параметры новому классу
})

// при клике

// проверка кода

// задаём значение которое будет проверятся
describe("pow", function() {

	// показываем что мы проверяем в коде
	it("возводит число в степень n", function() {
	  // задаём функцыю которая будет проверять результат
	  // в скобках мы пишеи действие, а за тем нужное значение 	
	  assert.equal(pow(2, 3), 8);
	  assert.equal(pow(3, 3), 27);
	});
  
  });

// при нажатии контрол + точка то в коде ниже везде при надобности поставят точку с запятой



// ctrl + / = ;  
// ctrl + v = отступ всего выделеного